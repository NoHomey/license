(function() {
  var ASSUMED_UNITS, HALF_PI, Macro, Plotter, THREEHALF_PI, TWO_PI, coordFactor, tool, unique;

  unique = require('./unique-id');

  Macro = require('./macro-tool');

  tool = require('./standard-tool');

  coordFactor = require('./svg-coord').factor;

  HALF_PI = Math.PI / 2;

  THREEHALF_PI = 3 * HALF_PI;

  TWO_PI = 2 * Math.PI;

  ASSUMED_UNITS = 'in';

  Plotter = (function() {
    function Plotter(reader, parser, opts) {
      var ref, ref1;
      this.reader = reader;
      this.parser = parser;
      if (opts == null) {
        opts = {};
      }
      this.units = (ref = opts.units) != null ? ref : null;
      this.notation = (ref1 = opts.notation) != null ? ref1 : null;
      this.macros = {};
      this.tools = {};
      this.currentTool = '';
      this.defs = [];
      this.group = {
        g: {
          _: []
        }
      };
      this.polarity = 'D';
      this.current = [];
      this.stepRepeat = {
        x: 1,
        y: 1,
        i: 0,
        j: 0
      };
      this.srOverClear = false;
      this.srOverCurrent = [];
      this.mode = null;
      this.quad = null;
      this.lastOp = null;
      this.region = false;
      this.done = false;
      this.pos = {
        x: 0,
        y: 0
      };
      this.path = [];
      this.attr = {
        'stroke-linecap': 'round',
        'stroke-linejoin': 'round',
        'stroke-width': 0,
        stroke: '#000'
      };
      this.bbox = {
        xMin: Infinity,
        yMin: Infinity,
        xMax: -Infinity,
        yMax: -Infinity
      };
      this.layerBbox = {
        xMin: Infinity,
        yMin: Infinity,
        xMax: -Infinity,
        yMax: -Infinity
      };
    }

    Plotter.prototype.addTool = function(code, params) {
      var obj, t;
      if (this.tools[code] != null) {
        throw new Error("cannot reassign tool " + code);
      }
      if (params.macro != null) {
        t = this.macros[params.macro].run(code, params.mods);
      } else {
        t = tool(code, params);
      }
      this.tools[code] = {
        trace: t.trace,
        pad: (function() {
          var k, len, ref, results;
          ref = t.pad;
          results = [];
          for (k = 0, len = ref.length; k < len; k++) {
            obj = ref[k];
            results.push(obj);
          }
          return results;
        })(),
        flash: function(x, y) {
          return {
            use: {
              x: x,
              y: y,
              'xlink:href': "#" + t.padId
            }
          };
        },
        flashed: false,
        bbox: function(x, y) {
          if (x == null) {
            x = 0;
          }
          if (y == null) {
            y = 0;
          }
          return {
            xMin: x + t.bbox[0],
            yMin: y + t.bbox[1],
            xMax: x + t.bbox[2],
            yMax: y + t.bbox[3]
          };
        }
      };
      return this.changeTool(code);
    };

    Plotter.prototype.changeTool = function(code) {
      var ref;
      this.finishPath();
      if (this.region) {
        throw new Error('cannot change tool when in region mode');
      }
      if (this.tools[code] == null) {
        if (!((ref = this.parser) != null ? ref.fmat : void 0)) {
          throw new Error("tool " + code + " is not defined");
        }
      } else {
        return this.currentTool = code;
      }
    };

    Plotter.prototype.command = function(c) {
      var code, m, params, ref, ref1, state, val;
      if (c.macro != null) {
        m = new Macro(c.macro, this.parser.format.places);
        this.macros[m.name] = m;
        return;
      }
      ref = c.set;
      for (state in ref) {
        val = ref[state];
        if (state === 'region') {
          this.finishPath();
        }
        switch (state) {
          case 'currentTool':
            this.changeTool(val);
            break;
          case 'units':
          case 'notation':
            if (this[state] == null) {
              this[state] = val;
            }
            break;
          default:
            this[state] = val;
        }
      }
      if (c.tool != null) {
        ref1 = c.tool;
        for (code in ref1) {
          params = ref1[code];
          this.addTool(code, params);
        }
      }
      if (c.op != null) {
        this.operate(c.op);
      }
      if (c["new"] != null) {
        this.finishLayer();
        if (c["new"].layer != null) {
          return this.polarity = c["new"].layer;
        } else if (c["new"].sr != null) {
          this.finishSR();
          return this.stepRepeat = c["new"].sr;
        }
      }
    };

    Plotter.prototype.plot = function() {
      var block, ref;
      while (!this.done) {
        block = this.reader.nextBlock();
        if (block === false) {
          if (((ref = this.parser) != null ? ref.fmat : void 0) == null) {
            throw new Error('end of file encountered before required M02 command');
          } else {
            throw new Error('end of drill file encountered before M00/M30 command');
          }
        } else {
          this.command(this.parser.parseCommand(block));
        }
      }
      return this.finish();
    };

    Plotter.prototype.finish = function() {
      this.finishPath();
      this.finishLayer();
      this.finishSR();
      this.group.g.fill = 'currentColor';
      this.group.g.stroke = 'currentColor';
      return this.group.g.transform = "translate(0," + (this.bbox.yMin + this.bbox.yMax) + ") scale(1,-1)";
    };

    Plotter.prototype.finishSR = function() {
      var k, l, layer, len, m, maskId, n, ref, ref1, ref2, ref3, ref4, ref5, u, x, y;
      if (this.srOverClear && this.srOverCurrent) {
        maskId = "gerber-sr-mask_" + (unique());
        m = {
          mask: {
            color: '#000',
            id: maskId,
            _: []
          }
        };
        m.mask._.push({
          rect: {
            fill: '#fff',
            x: this.bbox.xMin,
            y: this.bbox.yMin,
            width: this.bbox.xMax - this.bbox.xMin,
            height: this.bbox.yMax - this.bbox.yMin
          }
        });
        for (x = k = 0, ref = this.stepRepeat.x * this.stepRepeat.i, ref1 = this.stepRepeat.i; ref1 > 0 ? k < ref : k > ref; x = k += ref1) {
          for (y = l = 0, ref2 = this.stepRepeat.y * this.stepRepeat.j, ref3 = this.stepRepeat.j; ref3 > 0 ? l < ref2 : l > ref2; y = l += ref3) {
            ref4 = this.srOverCurrent;
            for (n = 0, len = ref4.length; n < len; n++) {
              layer = ref4[n];
              u = {
                use: {}
              };
              if (x !== 0) {
                u.use.x = x;
              }
              if (y !== 0) {
                u.use.y = y;
              }
              u.use['xlink:href'] = '#' + ((ref5 = layer.C) != null ? ref5 : layer.D);
              if (layer.D != null) {
                u.use.fill = '#fff';
              }
              m.mask._.push(u);
            }
          }
        }
        this.srOverClear = false;
        this.srOverCurrent = [];
        this.defs.push(m);
        return this.group.g.mask = "url(#" + maskId + ")";
      }
    };

    Plotter.prototype.finishLayer = function() {
      var c, h, id, k, l, len, n, obj, ref, ref1, ref2, srId, u, w, x, y;
      this.finishPath();
      if (!this.current.length) {
        return;
      }
      if (this.stepRepeat.x > 1 || this.stepRepeat.y > 1) {
        srId = "gerber-sr_" + (unique());
        this.current = [
          {
            g: {
              id: srId,
              _: this.current
            }
          }
        ];
        if (this.srOverClear || this.stepRepeat.i < this.layerBbox.xMax - this.layerBbox.xMin || this.stepRepeat.j < this.layerBbox.yMax - this.layerBbox.yMin) {
          obj = {};
          obj[this.polarity] = srId;
          this.srOverCurrent.push(obj);
          if (this.polarity === 'C') {
            this.srOverClear = true;
            this.defs.push(this.current[0]);
          }
        }
        for (x = k = 0, ref = this.stepRepeat.x; 0 <= ref ? k < ref : k > ref; x = 0 <= ref ? ++k : --k) {
          for (y = l = 0, ref1 = this.stepRepeat.y; 0 <= ref1 ? l < ref1 : l > ref1; y = 0 <= ref1 ? ++l : --l) {
            if (!(x === 0 && y === 0)) {
              u = {
                use: {
                  'xlink:href': "#" + srId
                }
              };
              if (x !== 0) {
                u.use.x = x * this.stepRepeat.i;
              }
              if (y !== 0) {
                u.use.y = y * this.stepRepeat.j;
              }
              this.current.push(u);
            }
          }
        }
        this.layerBbox.xMax += (this.stepRepeat.x - 1) * this.stepRepeat.i;
        this.layerBbox.yMax += (this.stepRepeat.y - 1) * this.stepRepeat.j;
      }
      this.addBbox(this.layerBbox, this.bbox);
      this.layerBbox = {
        xMin: Infinity,
        yMin: Infinity,
        xMax: -Infinity,
        yMax: -Infinity
      };
      if (this.polarity === 'D') {
        if (this.group.g.mask != null) {
          this.current.unshift(this.group);
        }
        if ((this.group.g.mask == null) && this.group.g._.length) {
          ref2 = this.current;
          for (n = 0, len = ref2.length; n < len; n++) {
            c = ref2[n];
            this.group.g._.push(c);
          }
        } else {
          this.group = {
            g: {
              _: this.current
            }
          };
        }
      } else if (this.polarity === 'C' && !this.srOverClear) {
        id = "gerber-mask_" + (unique());
        w = this.bbox.xMax - this.bbox.xMin;
        h = this.bbox.yMax - this.bbox.yMin;
        this.current.unshift({
          rect: {
            x: this.bbox.xMin,
            y: this.bbox.yMin,
            width: w,
            height: h,
            fill: '#fff'
          }
        });
        this.defs.push({
          mask: {
            id: id,
            color: '#000',
            _: this.current
          }
        });
        this.group.g.mask = "url(#" + id + ")";
      }
      return this.current = [];
    };

    Plotter.prototype.finishPath = function() {
      var key, p, ref, val;
      if (this.path.length) {
        p = {
          path: {}
        };
        if (this.region) {
          this.path.push('Z');
        } else {
          ref = this.tools[this.currentTool].trace;
          for (key in ref) {
            val = ref[key];
            p.path[key] = val;
          }
        }
        p.path.d = this.path;
        this.current.push(p);
        return this.path = [];
      }
    };

    Plotter.prototype.operate = function(op) {
      var bbox, ex, ey, k, len, ref, ref1, ref2, ref3, ref4, ref5, ref6, ref7, shape, sx, sy, t;
      if (op["do"] === 'last') {
        op["do"] = this.lastOp;
        console.warn('modal operation codes are deprecated');
      } else {
        this.lastOp = op["do"];
      }
      sx = this.pos.x;
      sy = this.pos.y;
      if (this.notation === 'I') {
        this.pos.x += (ref = op.x) != null ? ref : 0;
        this.pos.y += (ref1 = op.y) != null ? ref1 : 0;
      } else {
        this.pos.x = (ref2 = op.x) != null ? ref2 : this.pos.x;
        this.pos.y = (ref3 = op.y) != null ? ref3 : this.pos.y;
      }
      ex = this.pos.x;
      ey = this.pos.y;
      t = this.tools[this.currentTool];
      if (this.units == null) {
        if (this.backupUnits != null) {
          this.units = this.backupUnits;
          console.warn("units set to '" + this.units + "' according to deprecated command G7" + (this.units === 'in' ? 0 : 1));
        } else {
          this.units = ASSUMED_UNITS;
          console.warn('no units set; assuming inches');
        }
      }
      if (this.notation == null) {
        if (((ref4 = this.parser) != null ? ref4.fmat : void 0) != null) {
          this.notation = 'A';
        } else {
          throw new Error('format has not been set');
        }
      }
      if (op["do"] === 'move' && this.path.length) {
        return this.path.push('M', ex, ey);
      } else if (op["do"] === 'flash') {
        this.finishPath();
        if (this.region) {
          throw new Error('cannot flash while in region mode');
        }
        if (!t.flashed) {
          ref5 = t.pad;
          for (k = 0, len = ref5.length; k < len; k++) {
            shape = ref5[k];
            this.defs.push(shape);
          }
          t.flashed = true;
        }
        this.current.push(t.flash(ex, ey));
        return this.addBbox(t.bbox(ex, ey), this.layerBbox);
      } else if (op["do"] === 'int') {
        if (!this.region && !t.trace) {
          throw new Error(this.currentTool + " is not a strokable tool");
        }
        if (this.path.length === 0) {
          this.path.push('M', sx, sy);
          bbox = !this.region ? t.bbox(sx, sy) : {
            xMin: sx,
            yMin: sy,
            xMax: sx,
            yMax: sy
          };
          this.addBbox(bbox, this.layerBbox);
        }
        if (this.mode == null) {
          this.mode = 'i';
          console.warn('no interpolation mode set. Assuming linear (G01)');
        }
        if (this.mode === 'i') {
          return this.drawLine(sx, sy, ex, ey);
        } else {
          return this.drawArc(sx, sy, ex, ey, (ref6 = op.i) != null ? ref6 : 0, (ref7 = op.j) != null ? ref7 : 0);
        }
      }
    };

    Plotter.prototype.drawLine = function(sx, sy, ex, ey) {
      var bbox, exm, exp, eym, eyp, halfHeight, halfWidth, sxm, sxp, sym, syp, t, theta;
      t = this.tools[this.currentTool];
      bbox = !this.region ? t.bbox(ex, ey) : {
        xMin: ex,
        yMin: ey,
        xMax: ex,
        yMax: ey
      };
      this.addBbox(bbox, this.layerBbox);
      if (this.region || t.trace['stroke-width'] >= 0) {
        return this.path.push('L', ex, ey);
      } else {
        halfWidth = t.pad[0].rect.width / 2;
        halfHeight = t.pad[0].rect.height / 2;
        sxm = sx - halfWidth;
        sxp = sx + halfWidth;
        sym = sy - halfHeight;
        syp = sy + halfHeight;
        exm = ex - halfWidth;
        exp = ex + halfWidth;
        eym = ey - halfHeight;
        eyp = ey + halfHeight;
        theta = Math.atan2(ey - sy, ex - sx);
        if ((0 <= theta && theta < HALF_PI)) {
          return this.path.push('M', sxm, sym, sxp, sym, exp, eym, exp, eyp, exm, eyp, sxm, syp, 'Z');
        } else if ((HALF_PI <= theta && theta <= Math.PI)) {
          return this.path.push('M', sxm, sym, sxp, sym, sxp, syp, exp, eyp, exm, eyp, exm, eym, 'Z');
        } else if ((-Math.PI <= theta && theta < -HALF_PI)) {
          return this.path.push('M', sxp, sym, sxp, syp, sxm, syp, exm, eyp, exm, eym, exp, eym, 'Z');
        } else if ((-HALF_PI <= theta && theta < 0)) {
          return this.path.push('M', sxm, sym, exm, eym, exp, eym, exp, eyp, sxp, syp, sxm, syp, 'Z');
        }
      }
    };

    Plotter.prototype.drawArc = function(sx, sy, ex, ey, i, j) {
      var arcEps, c, cand, cen, dist, k, l, large, len, len1, r, rTool, ref, ref1, ref2, sweep, t, theta, thetaE, thetaS, validCen, xMax, xMin, xn, xp, yMax, yMin, yn, yp, zeroLength;
      arcEps = 1.5 * coordFactor * Math.pow(10, -1 * ((ref = (ref1 = this.parser) != null ? ref1.format.places[1] : void 0) != null ? ref : 7));
      t = this.tools[this.currentTool];
      if (!this.region && !t.trace['stroke-width']) {
        throw Error("cannot stroke an arc with non-circular tool " + this.currentTool);
      }
      if (this.quad == null) {
        throw new Error('arc quadrant mode has not been set');
      }
      r = Math.sqrt(Math.pow(i, 2) + Math.pow(j, 2));
      sweep = this.mode === 'cw' ? 0 : 1;
      large = 0;
      validCen = [];
      cand = [[sx + i, sy + j]];
      if (this.quad === 's') {
        cand.push([sx - i, sy - j], [sx - i, sy + j], [sx + i, sy - j]);
      }
      for (k = 0, len = cand.length; k < len; k++) {
        c = cand[k];
        dist = Math.sqrt(Math.pow(c[0] - ex, 2) + Math.pow(c[1] - ey, 2));
        if ((Math.abs(r - dist)) < arcEps) {
          validCen.push({
            x: c[0],
            y: c[1]
          });
        }
      }
      thetaE = 0;
      thetaS = 0;
      cen = null;
      for (l = 0, len1 = validCen.length; l < len1; l++) {
        c = validCen[l];
        thetaE = Math.atan2(ey - c.y, ex - c.x);
        if (thetaE < 0) {
          thetaE += TWO_PI;
        }
        thetaS = Math.atan2(sy - c.y, sx - c.x);
        if (thetaS < 0) {
          thetaS += TWO_PI;
        }
        if (this.mode === 'cw' && thetaS < thetaE) {
          thetaS += TWO_PI;
        } else if (this.mode === 'ccw' && thetaE < thetaS) {
          thetaE += TWO_PI;
        }
        theta = Math.abs(thetaE - thetaS);
        if (this.quad === 's' && theta <= HALF_PI) {
          cen = c;
        } else if (this.quad === 'm') {
          if (theta >= Math.PI) {
            large = 1;
          }
          cen = {
            x: c.x,
            y: c.y
          };
        }
        if (cen != null) {
          break;
        }
      }
      if (cen == null) {
        console.warn("start " + sx + "," + sy + " " + this.mode + " to end " + ex + "," + ey + " with center offset " + i + "," + j + " is an impossible arc in " + (this.quad === 's' ? 'single' : 'multi') + " quadrant mode with epsilon set to " + arcEps);
        return;
      }
      rTool = this.region ? 0 : t.bbox().xMax;
      if (this.mode === 'cw') {
        ref2 = [thetaS, thetaE], thetaE = ref2[0], thetaS = ref2[1];
      }
      xp = thetaS > 0 ? TWO_PI : 0;
      yp = HALF_PI + (thetaS > HALF_PI ? TWO_PI : 0);
      xn = Math.PI + (thetaS > Math.PI ? TWO_PI : 0);
      yn = THREEHALF_PI + (thetaS > THREEHALF_PI ? TWO_PI : 0);
      if ((thetaS <= xn && xn <= thetaE)) {
        xMin = cen.x - r - rTool;
      } else {
        xMin = (Math.min(sx, ex)) - rTool;
      }
      if ((thetaS <= xp && xp <= thetaE)) {
        xMax = cen.x + r + rTool;
      } else {
        xMax = (Math.max(sx, ex)) + rTool;
      }
      if ((thetaS <= yn && yn <= thetaE)) {
        yMin = cen.y - r - rTool;
      } else {
        yMin = (Math.min(sy, ey)) - rTool;
      }
      if ((thetaS <= yp && yp <= thetaE)) {
        yMax = cen.y + r + rTool;
      } else {
        yMax = (Math.max(sy, ey)) + rTool;
      }
      zeroLength = (Math.abs(sx - ex) < arcEps) && (Math.abs(sy - ey) < arcEps);
      if (this.quad === 'm' && zeroLength) {
        this.path.push('A', r, r, 0, 0, sweep, ex + 2 * i, ey + 2 * j);
        xMin = cen.x - r - rTool;
        yMin = cen.y - r - rTool;
        xMax = cen.x + r + rTool;
        yMax = cen.y + r + rTool;
      }
      this.path.push('A', r, r, 0, large, sweep, ex, ey);
      if (this.quad === 's' && zeroLength) {
        this.path.push('Z');
      }
      return this.addBbox({
        xMin: xMin,
        yMin: yMin,
        xMax: xMax,
        yMax: yMax
      }, this.layerBbox);
    };

    Plotter.prototype.addBbox = function(bbox, target) {
      if (bbox.xMin < target.xMin) {
        target.xMin = bbox.xMin;
      }
      if (bbox.yMin < target.yMin) {
        target.yMin = bbox.yMin;
      }
      if (bbox.xMax > target.xMax) {
        target.xMax = bbox.xMax;
      }
      if (bbox.yMax > target.yMax) {
        return target.yMax = bbox.yMax;
      }
    };

    return Plotter;

  })();

  module.exports = Plotter;

}).call(this);
