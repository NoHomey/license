(function() {
  var MacroTool, calc, getSvgCoord, shapes, unique;

  shapes = require('./pad-shapes');

  calc = require('./macro-calc');

  unique = require('./unique-id');

  getSvgCoord = require('./svg-coord').get;

  MacroTool = (function() {
    function MacroTool(blocks, numberFormat) {
      this.modifiers = {};
      this.name = blocks[0].slice(2);
      this.blocks = blocks.slice(1);
      this.shapes = [];
      this.masks = [];
      this.lastExposure = null;
      this.bbox = [null, null, null, null];
      this.format = {
        places: numberFormat
      };
    }

    MacroTool.prototype.run = function(tool, modifiers) {
      var b, group, i, j, k, l, len, len1, len2, len3, m, n, pad, padId, ref, ref1, ref2, s, shape;
      if (modifiers == null) {
        modifiers = [];
      }
      this.lastExposure = null;
      this.shapes = [];
      this.masks = [];
      this.bbox = [null, null, null, null];
      this.modifiers = {};
      for (i = j = 0, len = modifiers.length; j < len; i = ++j) {
        m = modifiers[i];
        this.modifiers["$" + (i + 1)] = m;
      }
      ref = this.blocks;
      for (k = 0, len1 = ref.length; k < len1; k++) {
        b = ref[k];
        this.runBlock(b);
      }
      padId = "tool-" + tool + "-pad-" + (unique());
      pad = [];
      ref1 = this.masks;
      for (l = 0, len2 = ref1.length; l < len2; l++) {
        m = ref1[l];
        pad.push(m);
      }
      if (this.shapes.length > 1) {
        group = {
          id: padId,
          _: []
        };
        ref2 = this.shapes;
        for (n = 0, len3 = ref2.length; n < len3; n++) {
          s = ref2[n];
          group._.push(s);
        }
        pad = [
          {
            g: group
          }
        ];
      } else if (this.shapes.length === 1) {
        shape = Object.keys(this.shapes[0])[0];
        this.shapes[0][shape].id = padId;
        pad.push(this.shapes[0]);
      }
      return {
        pad: pad,
        padId: padId,
        bbox: this.bbox,
        trace: false
      };
    };

    MacroTool.prototype.runBlock = function(block) {
      var a, args, i, j, len, mod, ref, val;
      switch (block[0]) {
        case '$':
          mod = (ref = block.match(/^\$\d+(?=\=)/)) != null ? ref[0] : void 0;
          val = block.slice(1 + mod.length);
          return this.modifiers[mod] = this.getNumber(val);
        case '1':
        case '2':
        case '20':
        case '21':
        case '22':
        case '4':
        case '5':
        case '6':
        case '7':
          args = block.split(',');
          for (i = j = 0, len = args.length; j < len; i = ++j) {
            a = args[i];
            args[i] = this.getNumber(a);
          }
          return this.primitive(args);
        default:
          if (block[0] !== '0') {
            throw new Error("'" + block + "' unrecognized tool macro block");
          }
      }
    };

    MacroTool.prototype.primitive = function(args) {
      var group, i, j, k, key, l, len, len1, len2, len3, len4, m, mask, maskId, n, o, points, q, ref, ref1, ref2, ref3, ref4, ref5, results, rot, rotation, s, shape;
      mask = false;
      rotation = false;
      shape = null;
      switch (args[0]) {
        case 1:
          shape = shapes.circle({
            dia: getSvgCoord(args[2], this.format),
            cx: getSvgCoord(args[3], this.format),
            cy: getSvgCoord(args[4], this.format)
          });
          if (args[1] === 0) {
            mask = true;
          } else {
            this.addBbox(shape.bbox);
          }
          break;
        case 2:
        case 20:
          shape = shapes.vector({
            width: getSvgCoord(args[2], this.format),
            x1: getSvgCoord(args[3], this.format),
            y1: getSvgCoord(args[4], this.format),
            x2: getSvgCoord(args[5], this.format),
            y2: getSvgCoord(args[6], this.format)
          });
          if (args[7]) {
            shape.shape.line.transform = "rotate(" + args[7] + ")";
          }
          if (args[1] === 0) {
            mask = true;
          } else {
            this.addBbox(shape.bbox, args[7]);
          }
          break;
        case 21:
          shape = shapes.rect({
            cx: getSvgCoord(args[4], this.format),
            cy: getSvgCoord(args[5], this.format),
            width: getSvgCoord(args[2], this.format),
            height: getSvgCoord(args[3], this.format)
          });
          if (args[6]) {
            shape.shape.rect.transform = "rotate(" + args[6] + ")";
          }
          if (args[1] === 0) {
            mask = true;
          } else {
            this.addBbox(shape.bbox, args[6]);
          }
          break;
        case 22:
          shape = shapes.lowerLeftRect({
            x: getSvgCoord(args[4], this.format),
            y: getSvgCoord(args[5], this.format),
            width: getSvgCoord(args[2], this.format),
            height: getSvgCoord(args[3], this.format)
          });
          if (args[6]) {
            shape.shape.rect.transform = "rotate(" + args[6] + ")";
          }
          if (args[1] === 0) {
            mask = true;
          } else {
            this.addBbox(shape.bbox, args[6]);
          }
          break;
        case 4:
          points = [];
          for (i = j = 3, ref = 3 + 2 * args[2]; j <= ref; i = j += 2) {
            points.push([getSvgCoord(args[i], this.format), getSvgCoord(args[i + 1], this.format)]);
          }
          shape = shapes.outline({
            points: points
          });
          if (rot = args[args.length - 1]) {
            shape.shape.polygon.transform = "rotate(" + rot + ")";
          }
          if (args[1] === 0) {
            mask = true;
          } else {
            this.addBbox(shape.bbox, args[args.length - 1]);
          }
          break;
        case 5:
          if (args[6] !== 0 && (args[3] !== 0 || args[4] !== 0)) {
            throw new RangeError('polygon center must be 0,0 if rotated in macro');
          }
          shape = shapes.polygon({
            cx: getSvgCoord(args[3], this.format),
            cy: getSvgCoord(args[4], this.format),
            dia: getSvgCoord(args[5], this.format),
            verticies: args[2],
            degrees: args[6]
          });
          if (args[1] === 0) {
            mask = true;
          } else {
            this.addBbox(shape.bbox);
          }
          break;
        case 6:
          if (args[9] !== 0 && (args[1] !== 0 || args[2] !== 0)) {
            throw new RangeError('moirÃ© center must be 0,0 if rotated in macro');
          }
          shape = shapes.moire({
            cx: getSvgCoord(args[1], this.format),
            cy: getSvgCoord(args[2], this.format),
            outerDia: getSvgCoord(args[3], this.format),
            ringThx: getSvgCoord(args[4], this.format),
            ringGap: getSvgCoord(args[5], this.format),
            maxRings: args[6],
            crossThx: getSvgCoord(args[7], this.format),
            crossLength: getSvgCoord(args[8], this.format)
          });
          if (args[9]) {
            ref1 = shape.shape;
            for (k = 0, len = ref1.length; k < len; k++) {
              s = ref1[k];
              if (s.line != null) {
                s.line.transform = "rotate(" + args[9] + ")";
              }
            }
          }
          this.addBbox(shape.bbox, args[9]);
          break;
        case 7:
          if (args[9] !== 0 && (args[1] !== 0 || args[2] !== 0)) {
            throw new RangeError('thermal center must be 0,0 if rotated in macro');
          }
          shape = shapes.thermal({
            cx: getSvgCoord(args[1], this.format),
            cy: getSvgCoord(args[2], this.format),
            outerDia: getSvgCoord(args[3], this.format),
            innerDia: getSvgCoord(args[4], this.format),
            gap: getSvgCoord(args[5], this.format)
          });
          if (args[6]) {
            ref2 = shape.shape;
            for (l = 0, len1 = ref2.length; l < len1; l++) {
              s = ref2[l];
              if (s.mask != null) {
                ref3 = s.mask._;
                for (n = 0, len2 = ref3.length; n < len2; n++) {
                  m = ref3[n];
                  if (m.rect != null) {
                    m.rect.transform = "rotate(" + args[6] + ")";
                  }
                }
              }
            }
          }
          this.addBbox(shape.bbox, args[6]);
          break;
        default:
          throw new Error(args[0] + " is not a valid primitive code");
      }
      if (mask) {
        for (key in shape.shape) {
          shape.shape[key].fill = '#000';
        }
        if (this.lastExposure !== 0) {
          this.lastExposure = 0;
          maskId = "macro-" + this.name + "-mask-" + (unique());
          m = {
            mask: {
              id: maskId
            }
          };
          m.mask._ = [
            {
              rect: {
                x: this.bbox[0],
                y: this.bbox[1],
                width: this.bbox[2] - this.bbox[0],
                height: this.bbox[3] - this.bbox[1],
                fill: '#fff'
              }
            }
          ];
          if (this.shapes.length === 1) {
            for (key in this.shapes[0]) {
              this.shapes[0][key].mask = "url(#" + maskId + ")";
            }
          } else if (this.shapes.length > 1) {
            group = {
              mask: "url(#" + maskId + ")",
              _: []
            };
            ref4 = this.shapes;
            for (o = 0, len3 = ref4.length; o < len3; o++) {
              s = ref4[o];
              group._.push(s);
            }
            this.shapes = [
              {
                g: group
              }
            ];
          }
          this.masks.push(m);
        }
        return this.masks[this.masks.length - 1].mask._.push(shape.shape);
      } else {
        this.lastExposure = 1;
        if (!Array.isArray(shape.shape)) {
          return this.shapes.push(shape.shape);
        } else {
          ref5 = shape.shape;
          results = [];
          for (q = 0, len4 = ref5.length; q < len4; q++) {
            s = ref5[q];
            if (s.mask != null) {
              results.push(this.masks.push(s));
            } else {
              results.push(this.shapes.push(s));
            }
          }
          return results;
        }
      }
    };

    MacroTool.prototype.addBbox = function(bbox, rotation) {
      var b, c, j, len, p, points, s, x, y;
      if (rotation == null) {
        rotation = 0;
      }
      if (!rotation) {
        if (this.bbox[0] === null || bbox[0] < this.bbox[0]) {
          this.bbox[0] = bbox[0];
        }
        if (this.bbox[1] === null || bbox[1] < this.bbox[1]) {
          this.bbox[1] = bbox[1];
        }
        if (this.bbox[2] === null || bbox[2] > this.bbox[2]) {
          this.bbox[2] = bbox[2];
        }
        if (this.bbox[3] === null || bbox[3] > this.bbox[3]) {
          return this.bbox[3] = bbox[3];
        }
      } else {
        s = Math.sin(rotation * Math.PI / 180);
        c = Math.cos(rotation * Math.PI / 180);
        if (Math.abs(s) < 0.000000001) {
          s = 0;
        }
        if (Math.abs(c) < 0.000000001) {
          c = 0;
        }
        points = [[bbox[0], bbox[1]], [bbox[2], bbox[1]], [bbox[2], bbox[3]], [bbox[0], bbox[3]]];
        for (j = 0, len = points.length; j < len; j++) {
          p = points[j];
          x = (p[0] * c) - (p[1] * s);
          y = (p[0] * s) + (p[1] * c);
          if (this.bbox[0] === null || x < this.bbox[0]) {
            this.bbox[0] = x;
          }
          if (this.bbox[1] === null || y < this.bbox[1]) {
            this.bbox[1] = y;
          }
          if (this.bbox[2] === null || x > this.bbox[2]) {
            this.bbox[2] = x;
          }
          if (this.bbox[3] === null || y > this.bbox[3]) {
            this.bbox[3] = y;
          }
        }
        return this.bbox = (function() {
          var k, len1, ref, results;
          ref = this.bbox;
          results = [];
          for (k = 0, len1 = ref.length; k < len1; k++) {
            b = ref[k];
            results.push(b === -0 ? 0 : b);
          }
          return results;
        }).call(this);
      }
    };

    MacroTool.prototype.getNumber = function(s) {
      if (s.match(/^[+-]?[\d.]+$/)) {
        return Number(s);
      } else if (s.match(/^\$\d+$/)) {
        return Number(this.modifiers[s]);
      } else {
        return this.evaluate(calc.parse(s));
      }
    };

    MacroTool.prototype.evaluate = function(op) {
      switch (op.type) {
        case 'n':
          return this.getNumber(op.val);
        case '+':
          return this.evaluate(op.left) + this.evaluate(op.right);
        case '-':
          return this.evaluate(op.left) - this.evaluate(op.right);
        case 'x':
          return this.evaluate(op.left) * this.evaluate(op.right);
        case '/':
          return this.evaluate(op.left) / this.evaluate(op.right);
      }
    };

    return MacroTool;

  })();

  module.exports = MacroTool;

}).call(this);
