(function() {
  var DEFAULT_OPTS, DrillParser, DrillReader, GerberParser, GerberReader, Plotter, builder, coordFactor;

  builder = require('./obj-to-xml');

  Plotter = require('./plotter');

  DrillReader = require('./drill-reader');

  DrillParser = require('./drill-parser');

  GerberReader = require('./gerber-reader');

  GerberParser = require('./gerber-parser');

  coordFactor = require('./svg-coord').factor;

  DEFAULT_OPTS = {
    drill: false,
    pretty: false,
    object: false,
    warnArr: null,
    places: null,
    zero: null,
    notation: null,
    units: null
  };

  module.exports = function(file, options) {
    var a, error, height, key, oldWarn, opts, p, parser, parserOpts, plotterOpts, reader, ref, root, val, width, xml, xmlObject;
    if (options == null) {
      options = {};
    }
    opts = {};
    for (key in DEFAULT_OPTS) {
      val = DEFAULT_OPTS[key];
      opts[key] = val;
    }
    for (key in options) {
      val = options[key];
      opts[key] = val;
    }
    if (typeof file === 'object') {
      if (file.svg != null) {
        return builder(file, {
          pretty: opts.pretty
        });
      } else {
        throw new Error('non SVG object cannot be converted to an SVG string');
      }
    }
    parserOpts = null;
    if ((opts.places != null) || (opts.zero != null)) {
      parserOpts = {
        places: opts.places,
        zero: opts.zero
      };
    }
    if (opts.drill) {
      reader = new DrillReader(file);
      parser = new DrillParser(parserOpts);
    } else {
      reader = new GerberReader(file);
      parser = new GerberParser(parserOpts);
    }
    plotterOpts = null;
    if ((opts.notation != null) || (opts.units != null)) {
      plotterOpts = {
        notation: opts.notation,
        units: opts.units
      };
    }
    p = new Plotter(reader, parser, plotterOpts);
    oldWarn = null;
    root = null;
    if (Array.isArray(opts.warnArr)) {
      root = typeof window !== "undefined" && window !== null ? window : global;
      if (root.console == null) {
        root.console = {};
      }
      oldWarn = root.console.warn;
      root.console.warn = function(chunk) {
        return opts.warnArr.push(chunk.toString());
      };
    }
    try {
      xmlObject = p.plot();
    } catch (_error) {
      error = _error;
      throw new Error("Error at line " + p.reader.line + " - " + error.message);
    } finally {
      if ((oldWarn != null) && (root != null)) {
        root.console.warn = oldWarn;
      }
    }
    if (!(p.bbox.xMin >= p.bbox.xMax)) {
      width = p.bbox.xMax - p.bbox.xMin;
    } else {
      p.bbox.xMin = 0;
      p.bbox.xMax = 0;
      width = 0;
    }
    if (!(p.bbox.yMin >= p.bbox.yMax)) {
      height = p.bbox.yMax - p.bbox.yMin;
    } else {
      p.bbox.yMin = 0;
      p.bbox.yMax = 0;
      height = 0;
    }
    xml = {
      svg: {
        xmlns: 'http://www.w3.org/2000/svg',
        version: '1.1',
        'xmlns:xlink': 'http://www.w3.org/1999/xlink',
        width: "" + (width / coordFactor) + p.units,
        height: "" + (height / coordFactor) + p.units,
        viewBox: [p.bbox.xMin, p.bbox.yMin, width, height],
        _: []
      }
    };
    ref = p.attr;
    for (a in ref) {
      val = ref[a];
      xml.svg[a] = val;
    }
    if (p.defs.length) {
      xml.svg._.push({
        defs: {
          _: p.defs
        }
      });
    }
    if (p.group.g._.length) {
      xml.svg._.push(p.group);
    }
    if (!opts.object) {
      return builder(xml, {
        pretty: opts.pretty
      });
    } else {
      return xml;
    }
  };

}).call(this);
