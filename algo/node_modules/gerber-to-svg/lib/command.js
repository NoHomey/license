(function() {
  var BANNER, BOOLEAN_OPTS, OPTIONS, STRING_OPTS, VERSION, chalk, fs, gerberToSvg, getOptions, help, minimatch, parseArgs, path, printOptions, run, stderr, streamCapture, version;

  fs = require('fs');

  path = require('path');

  parseArgs = require('minimist');

  chalk = require('chalk');

  minimatch = require('minimatch');

  gerberToSvg = require('./gerber-to-svg');

  streamCapture = function(stream) {
    var buf, oldWrite;
    oldWrite = stream.write;
    buf = '';
    stream.write = function(chunk, encoding, callback) {
      return buf += chunk.toString();
    };
    return {
      unhook: function() {
        return stream.write = oldWrite;
      },
      captured: function() {
        return buf;
      }
    };
  };

  stderr = function() {
    return streamCapture(process.stderr);
  };

  VERSION = require('../package.json').version;

  BANNER = 'Usage: gerber2svg [options] path/to/gerbers\nExamples:\n  `$ gerber2svg path/to/gerber.gbr` will write the svg to stdout\n  `$ gerber2svg -o some/dir path/to/gerb.gbr` will create some/dir/gerb.svg\n  `$ gerber2svg -d **/*.drl -o out -- gerb/*` will process any files in gerb\n      that end in \'.drl\' as a drill files, everything else as Gerber files,\n      and output to out';

  OPTIONS = [['o', 'out', '        specify an output directory'], ['q', 'quiet', '      do not print warnings and messages'], ['p', 'pretty', '     align SVG output prettily'], ['d', 'drill', '      process files mathing this glob as NC drill files'], ['f', 'format', "     override coordinate format with '[n_int,n_dec]'"], ['z', 'zero', "       override zero suppression with 'L' or 'T'"], ['u', 'units', "      override (without converting) units with 'mm' or 'in'"], ['n', 'notation', "   override absolute/incremental notation with 'A' or 'I'"], ['a', 'append-ext', ' append .svg rather than replace the extension'], ['j', 'json', '       output json rather than an xml string'], ['v', 'version', '    display version information'], ['h', 'help', '       display this help text']];

  STRING_OPTS = ['out', 'drill', 'format', 'zero', 'units', 'notation'];

  BOOLEAN_OPTS = ['quiet', 'pretty', 'json', 'append-ext', 'version', 'help'];

  printOptions = function() {
    var i, len, o, results;
    console.log('Options:');
    results = [];
    for (i = 0, len = OPTIONS.length; i < len; i++) {
      o = OPTIONS[i];
      results.push(console.log("  -" + o[0] + ", --" + o[1] + " " + o[2]));
    }
    return results;
  };

  getOptions = function() {
    var alias, i, len, o;
    alias = {};
    for (i = 0, len = OPTIONS.length; i < len; i++) {
      o = OPTIONS[i];
      alias[o[0]] = o[1];
    }
    return alias;
  };

  version = function() {
    return console.log("gerber-to-svg version " + VERSION);
  };

  help = function() {
    version();
    console.log(BANNER);
    return printOptions();
  };

  run = function() {
    var argv, e, err, file, fileExt, fileList, i, len, places, print, results, warn, write;
    argv = parseArgs(process.argv.slice(2), {
      alias: getOptions(),
      string: STRING_OPTS,
      boolean: BOOLEAN_OPTS
    });
    fileList = argv._;
    if (argv.version) {
      return version();
    }
    if (argv.help || (argv._.length === 0 && typeof argv.drill !== 'string')) {
      return help();
    }
    err = function(string) {
      return console.error(chalk.bold.red(string));
    };
    warn = function(string) {
      if (!argv.quiet) {
        return console.warn(chalk.bold.yellow(string));
      }
    };
    print = function(string) {
      if (!argv.quiet) {
        return console.log(chalk.bold.white(string));
      }
    };
    fileExt = argv.json ? '.json' : '.svg';
    write = function(string, filename) {
      var newName;
      if (typeof string === 'object') {
        string = JSON.stringify(string, null, (argv.pretty ? '  ' : ''));
      }
      if (!argv.out) {
        return process.stdout.write(string);
      } else {
        if (argv['append-ext']) {
          newName = path.basename(filename);
        } else {
          newName = path.basename(filename, path.extname(filename));
        }
        newName = path.join(argv.out, newName + fileExt);
        return fs.writeFile(newName, string, function(error) {
          if (!error) {
            return print(filename + " converted to " + newName);
          } else {
            return "Error writing to " + newName + ": " + error.code;
          }
        });
      }
    };
    if (argv.format != null) {
      try {
        places = JSON.parse(argv.format);
        if (places.length !== 2 || typeof places[0] !== 'number' || typeof places[1] !== 'number') {
          throw new Error();
        }
      } catch (_error) {
        e = _error;
        err("format must be specified as '[n_int,n_dec]'");
        return help();
      }
      argv.format = places;
    }
    if ((argv.zero != null) && argv.zero !== 'L' && argv.zero !== 'T') {
      err("zero suppression must be either 'L' for leading or 'T' for trailing");
      return help();
    }
    if ((argv.units != null) && argv.units !== 'mm' && argv.units !== 'in') {
      err("units must be either 'mm' for millimeters or 'in' for inches");
      return help();
    }
    if ((argv.notation != null) && argv.notation !== 'A' && argv.notation !== 'I') {
      err("notation must be either 'A' for absolute or 'I' for incremental");
      return help();
    }
    results = [];
    for (i = 0, len = fileList.length; i < len; i++) {
      file = fileList[i];
      results.push((function(file) {
        return fs.readFile(file, 'utf-8', function(error, data) {
          var hook, opts, ref, warnings;
          if (!error) {
            try {
              hook = stderr();
              opts = {
                pretty: argv.pretty,
                drill: minimatch(file, (ref = argv.drill) != null ? ref : ''),
                object: argv.json,
                places: argv.format,
                zero: argv.zero,
                units: argv.units,
                notation: argv.notation
              };
              return write(gerberToSvg(data, opts), file);
            } catch (_error) {
              e = _error;
              return warn("could not process " + file + ": " + e.message);
            } finally {
              warnings = hook.captured();
              hook.unhook();
              if (warnings) {
                warn(file + " produced the following warnings:\n" + warnings);
              }
            }
          } else {
            return warn("Error reading file " + file + ": " + error.code);
          }
        });
      })(file));
    }
    return results;
  };

  module.exports = run;

}).call(this);
