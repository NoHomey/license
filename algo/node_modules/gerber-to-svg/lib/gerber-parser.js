(function() {
  var GerberParser, Parser, getSvgCoord, parseCoord, reCOORD, reFS,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  Parser = require('./parser');

  parseCoord = require('./coord-parser');

  getSvgCoord = require('./svg-coord').get;

  reCOORD = /([XYIJ][+-]?\d+){1,4}/g;

  reFS = /^FS([A-Z]?)([A-Z]?)X([0-7])([0-7])Y\3\4/;

  GerberParser = (function(superClass) {
    extend(GerberParser, superClass);

    function GerberParser() {
      return GerberParser.__super__.constructor.apply(this, arguments);
    }

    GerberParser.prototype.parseFormat = function(p, c) {
      var _, base, base1, m, nota, pM, pN, zero;
      if (!(m = p.match(reFS))) {
        throw new Error('invalid format specification');
      }
      _ = m[0], zero = m[1], nota = m[2], pN = m[3], pM = m[4];
      if (zero !== 'L' && zero !== 'T') {
        console.warn('gerber zero suppression is not specified. assuming leading zero suppression (same as no zero suppression)');
        zero = 'L';
      }
      if (nota !== 'A' && nota !== 'I') {
        console.warn('gerber coordinate notation is not specified. assuming absolute notation');
        nota = 'A';
      }
      if ((base = this.format).zero == null) {
        base.zero = zero;
      }
      if ((base1 = this.format).places == null) {
        base1.places = [Number(pN), Number(pM)];
      }
      if (c.set == null) {
        c.set = {};
      }
      return c.set.notation = nota;
    };

    GerberParser.prototype.parseToolDef = function(p, c) {
      var code, hole, m, mods, ref, ref1, shape;
      if (c.tool == null) {
        c.tool = {};
      }
      code = (ref = p.match(/^ADD\d{2,}/)) != null ? ref[0].slice(2) : void 0;
      ref1 = p.slice(2 + code.length).split(','), shape = ref1[0], mods = ref1[1];
      mods = mods != null ? mods.split('X') : void 0;
      while (code[1] === '0') {
        code = code[0] + code.slice(2);
      }
      switch (shape) {
        case 'C':
          if (mods.length > 2) {
            hole = {
              width: getSvgCoord(mods[1], {
                places: this.format.places
              }),
              height: getSvgCoord(mods[2], {
                places: this.format.places
              })
            };
          } else if (mods.length > 1) {
            hole = {
              dia: getSvgCoord(mods[1], {
                places: this.format.places
              })
            };
          }
          c.tool[code] = {
            dia: getSvgCoord(mods[0], {
              places: this.format.places
            })
          };
          if (hole != null) {
            return c.tool[code].hole = hole;
          }
          break;
        case 'R':
        case 'O':
          if (mods.length > 3) {
            hole = {
              width: getSvgCoord(mods[2], {
                places: this.format.places
              }),
              height: getSvgCoord(mods[3], {
                places: this.format.places
              })
            };
          } else if (mods.length > 2) {
            hole = {
              dia: getSvgCoord(mods[2], {
                places: this.format.places
              })
            };
          }
          c.tool[code] = {
            width: getSvgCoord(mods[0], {
              places: this.format.places
            }),
            height: getSvgCoord(mods[1], {
              places: this.format.places
            })
          };
          if (shape === 'O') {
            c.tool[code].obround = true;
          }
          if (hole != null) {
            return c.tool[code].hole = hole;
          }
          break;
        case 'P':
          if (mods.length > 4) {
            hole = {
              width: getSvgCoord(mods[3], {
                places: this.format.places
              }),
              height: getSvgCoord(mods[4], {
                places: this.format.places
              })
            };
          } else if (mods.length > 3) {
            hole = {
              dia: getSvgCoord(mods[3], {
                places: this.format.places
              })
            };
          }
          c.tool[code] = {
            dia: getSvgCoord(mods[0], {
              places: this.format.places
            }),
            verticies: +mods[1]
          };
          if (mods.length > 2) {
            c.tool[code].degrees = +mods[2];
          }
          if (hole != null) {
            return c.tool[code].hole = hole;
          }
          break;
        default:
          mods = (function() {
            var k, len, ref2, results;
            ref2 = mods != null ? mods : [];
            results = [];
            for (k = 0, len = ref2.length; k < len; k++) {
              m = ref2[k];
              results.push(+m);
            }
            return results;
          })();
          return c.tool[code] = {
            macro: shape,
            mods: mods
          };
      }
    };

    GerberParser.prototype.parseCommand = function(block) {
      var axis, c, code, coord, i, j, k, len, m, op, p, param, ref, ref1, ref2, ref3, ref4, ref5, ref6, ref7, ref8, ref9, tool, u, val, x, y;
      if (block == null) {
        block = {};
      }
      c = {};
      if (param = block.param) {
        for (k = 0, len = param.length; k < len; k++) {
          p = param[k];
          switch (code = p.slice(0, 2)) {
            case 'FS':
              this.parseFormat(p, c);
              break;
            case 'MO':
              u = p.slice(2, 4);
              if (c.set == null) {
                c.set = {};
              }
              if (u === 'IN') {
                c.set.units = 'in';
              } else if (u === 'MM') {
                c.set.units = 'mm';
              } else {
                throw new Error(p + " is an invalid units setting");
              }
              break;
            case 'AD':
              this.parseToolDef(p, c);
              break;
            case 'AM':
              return {
                macro: param
              };
            case 'LP':
              if (c["new"] == null) {
                c["new"] = {};
              }
              if (p[2] === 'D' || p[2] === 'C') {
                c["new"].layer = p[2];
              }
              if (c["new"].layer == null) {
                throw new Error('invalid level polarity');
              }
              break;
            case 'SR':
              if (c["new"] == null) {
                c["new"] = {};
              }
              x = (ref = (ref1 = p.match(/X[+-]?[\d\.]+/)) != null ? ref1[0].slice(1) : void 0) != null ? ref : 1;
              y = (ref2 = (ref3 = p.match(/Y[+-]?[\d\.]+/)) != null ? ref3[0].slice(1) : void 0) != null ? ref2 : 1;
              i = (ref4 = p.match(/I[+-]?[\d\.]+/)) != null ? ref4[0].slice(1) : void 0;
              j = (ref5 = p.match(/J[+-]?[\d\.]+/)) != null ? ref5[0].slice(1) : void 0;
              if ((x < 1 || y < 1) || (x > 1 && ((i == null) || i < 0)) || (y > 1 && ((j == null) || j < 0))) {
                throw new Error('invalid step repeat');
              }
              c["new"].sr = {
                x: +x,
                y: +y
              };
              if (i != null) {
                c["new"].sr.i = getSvgCoord(i, {
                  places: this.format.places
                });
              }
              if (j != null) {
                c["new"].sr.j = getSvgCoord(j, {
                  places: this.format.places
                });
              }
          }
        }
      } else if (block = block.block) {
        if (block === 'M02') {
          return {
            set: {
              done: true
            }
          };
        } else if (block[0] === 'G') {
          switch (code = (ref6 = block.slice(1).match(/^\d{1,2}/)) != null ? ref6[0] : void 0) {
            case '4':
            case '04':
              return {};
            case '1':
            case '01':
            case '2':
            case '02':
            case '3':
            case '03':
              code = code[code.length - 1];
              m = code === '1' ? 'i' : code === '2' ? 'cw' : 'ccw';
              c.set = {
                mode: m
              };
              break;
            case '36':
            case '37':
              c.set = {
                region: code === '36'
              };
              break;
            case '70':
            case '71':
              c.set = {
                backupUnits: code === '70' ? 'in' : 'mm'
              };
              break;
            case '74':
            case '75':
              c.set = {
                quad: code === '74' ? 's' : 'm'
              };
          }
        }
        coord = parseCoord((ref7 = block.match(reCOORD)) != null ? ref7[0] : void 0, this.format);
        if (op = ((ref8 = block.match(/D0?[123]$/)) != null ? ref8[0] : void 0) || Object.keys(coord).length) {
          if (op != null) {
            op = op[op.length - 1];
          }
          op = (function() {
            switch (op) {
              case '1':
                return 'int';
              case '2':
                return 'move';
              case '3':
                return 'flash';
              default:
                return 'last';
            }
          })();
          c.op = {
            "do": op
          };
          for (axis in coord) {
            val = coord[axis];
            c.op[axis] = val;
          }
        } else if (tool = (ref9 = block.match(/D\d+$/)) != null ? ref9[0] : void 0) {
          c.set = {
            currentTool: tool
          };
        }
      }
      return c;
    };

    return GerberParser;

  })(Parser);

  module.exports = GerberParser;

}).call(this);
