(function() {
  var ABS_COMMAND, DrillParser, INCH_COMMAND, INC_COMMAND, METRIC_COMMAND, PLACES_BACKUP, Parser, ZERO_BACKUP, getSvgCoord, parseCoord, reCOORD,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  Parser = require('./parser');

  parseCoord = require('./coord-parser');

  getSvgCoord = require('./svg-coord').get;

  INCH_COMMAND = {
    'FMAT,1': 'M70',
    'FMAT,2': 'M72'
  };

  METRIC_COMMAND = 'M71';

  ABS_COMMAND = 'G90';

  INC_COMMAND = 'G91';

  reCOORD = /[XY]{1,2}/;

  ZERO_BACKUP = 'L';

  PLACES_BACKUP = [2, 4];

  DrillParser = (function(superClass) {
    extend(DrillParser, superClass);

    function DrillParser() {
      this.fmat = 'FMAT,2';
      DrillParser.__super__.constructor.call(this, arguments[0]);
    }

    DrillParser.prototype.parseCommand = function(block) {
      var base, base1, base2, base3, code, command, dia, k, ref, ref1, ref2, v;
      command = {};
      if (block[0] === ';') {
        return command;
      }
      if (block === 'FMAT,1') {
        this.fmat = block;
      } else if (block === 'M30' || block === 'M00') {
        command.set = {
          done: true
        };
      } else if (block === INCH_COMMAND[this.fmat] || block.match(/INCH/)) {
        if ((base = this.format).places == null) {
          base.places = [2, 4];
        }
        command.set = {
          units: 'in'
        };
      } else if (block === METRIC_COMMAND || block.match(/METRIC/)) {
        if ((base1 = this.format).places == null) {
          base1.places = [3, 3];
        }
        command.set = {
          units: 'mm'
        };
      } else if (block === ABS_COMMAND) {
        command.set = {
          notation: 'A'
        };
      } else if (block === INC_COMMAND) {
        command.set = {
          notation: 'I'
        };
      } else if ((code = (ref = block.match(/T\d+/)) != null ? ref[0] : void 0)) {
        while (code[1] === '0') {
          code = code[0] + code.slice(2);
        }
        if ((dia = (ref1 = block.match(/C[\d\.]+(?=.*$)/)) != null ? ref1[0] : void 0)) {
          dia = dia.slice(1);
          command.tool = {};
          command.tool[code] = {
            dia: getSvgCoord(dia, {
              places: this.format.places
            })
          };
        } else {
          command.set = {
            currentTool: code
          };
        }
      }
      if (block.match(/TZ/)) {
        if ((base2 = this.format).zero == null) {
          base2.zero = 'L';
        }
      } else if (block.match(/LZ/)) {
        if ((base3 = this.format).zero == null) {
          base3.zero = 'T';
        }
      }
      if (block.match(reCOORD)) {
        command.op = {
          "do": 'flash'
        };
        if (this.format.zero == null) {
          console.warn('no drill file zero suppression specified. assuming leading zero suppression (same as no zero suppression)');
          this.format.zero = ZERO_BACKUP;
        }
        if (this.format.places == null) {
          console.warn('no drill file units specified; assuming 2:4 inches format');
          this.format.places = PLACES_BACKUP;
        }
        ref2 = parseCoord(block, this.format);
        for (k in ref2) {
          v = ref2[k];
          command.op[k] = v;
        }
      }
      return command;
    };

    return DrillParser;

  })(Parser);

  module.exports = DrillParser;

}).call(this);
